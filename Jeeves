Here is a description of the retired Jeeves pwnbox:

"Jeeves is not overly complicated, however, it focuses on some interesting techniques and provides a great learning experience. As the use of alternate data streams is not very common, some users may have a hard time locating the correct escalation path."

I used @PinkDraconian's YouTube video for inspiration to better understand binary exploitation and how to execute buffer overflow on this challenge. I highly suggest you give him a follow for more OffSec and HTB CTF content!

https://www.youtube.com/watch?v=W5dVsa3__N4
https://github.com/PinkDraconian 

In order to open this file, we have to use the chmod +x command to give us execute priveleges:

chmod +x jeeves

To find out what kind of file we're working with, use the command:
file jeeves 



Checking out the binary:
• it's 64-bits
• it's not stripped which means that all the original names are still in there. The function names, etc.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The first thing we do is go into Ghidra: https://github.com/NationalSecurityAgency/ghidra

Using Ghidra
Ghidra is a very nice tool that allows us to generate some pseudo c code from the non-user-friendly assembly code.

ghidra jeeves


From opening Jeeves into Ghidra, we can see that there's only really a main function here from the /symbol tree, and let's break down the main function in a simple way.

1. First Output: 
   "Hello, good sir! May I have your name?
   
2. You give it an input:
   <name>
   
3. It Outputs the received input in the final Output: 
   Hello <name>, hope you have a good day!

4. However if this <name> variable is equal to {0x1337bab3} it's going to open flag.txt and print it out to us.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Okay so let's see if this is also what happens when we run the program. 

When we execute the file using the ./jeeves command, we see the following (as expected):



Now that we know the output behavior when the input is expected, let's try to fuzz the program to see if we can generate an unexpected result.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 in Line 5, (local_48) is defined by an array of 44 characters.


Knowing this, what if we enter more than 44 characters..?

This leads us to the approach to the theme of the box: to use Buffer Overflow on this stack. 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Using this function below, we'll output 48 “a" characters to use when the jeeves program prompts our input. We can later update the number of “a” characters needed.

	python -c "print('a' * 48)"    

Now run ./jeeves again and copy + paste the 48 “a” characters when it prompts us for our input + press enter.



On the front-end, the behavior still looks similar to the intended output.


Let's try 100 “a" characters


 
We got a segmentation fault error using 100 “a” characters.

The segmentation fault means we were successful in our overflow by overwriting the return address on the stack.
 
However, we overflowed too far! We do not want this as we wanted the overflow to STOP on line 8, so it can output us the flag.
 
 
 
 

Note: Although we overflowed the stack using 48-characters, we did not receive a segmentation fault.


The return function on line 21 could not output the flag as Assembly could not process the answer, so let's continue with another route knowing this.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The stack requires information from the top, and calls those functions/inputs to be used in later lines.


 
Let's break this down:
 5: our buffer, the input is defined as 44 characters
 6: integer
 7: the pointer
 8: what we intend to overwrite to capture the flag
 
Since our buffer is on top of the stack, if we overflow there, everything below it could also be overflowed... including local_c in Line 8, so we need to find a way to overflow lines 5-7, but not 8.
 
What we need to provide for Line 8 can be found in Line 14.
We want the (local_c) variable to equal to "0x1337bab3" in order to capture the flag. 


This (local_c) variable is defined earlier in line 10 with the hexcode "DEADC0D3h" so anything that is not "1337BAB3h" will result in no flag.


Line 12, shows us our inputs will be going into the "gets(local_48)" function, though we do not know if there are any character limits to (local_48). 

However, in Line 5, (local_48) is defined by an array of 44 characters.


Knowing this, what if we enter more than 44 characters..?

This leads to our first theory to use Buffer Overflow on this stack. 
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In order to do this, we need to know how many bytes it will take to reach their positions. On the left-hand side, we see the hexadecimals of the values. 

We can quickly convert this to decimals using the internet.



Example: 
• local_c is located at the Stack [-0xc] hexadecimal

First convert the first and last lines of the stack from Hexadecimal to Decimal.

From our results:
	local_c [-0xc] -> 12 
	local_48 [-0x48] -> 72

72-12 = 60 bytes needed to reach Line 8 local_c, but not overflow it!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

or (if we do not have the internet)

We hover over our stack to find each length from the stack and add them up:
 
 
 
| Stack  | bytes |
| char (buffer - name) | 44 |
| int | 4 |
| void (pointer) | 8 |
| int | 4 |
| Total | 60 padding bytes |

 
44 + 4 + 8 + 4
= 60 bytes needed to reach Line 8 local_c, but not overflow it!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Our payload will have 60 “a” characters, THEN include the local_c hexadecimal value. Let's use pwn-tools and create a script to do this.



The script uses pwn-tools to:
1. First, create a Remote SSH tunnel from our localhost machine to target machine using port 30381.
   
2. Send our custom payload of the 60 “a” characters + desired local_c hexadecimal value.
      → Note that we need to include b to notate “bytes” in front of ‘A’ as the script would be trying to concenate dissimilar variables (a string with bytes).
         
3. Print out the messages once the payload has been received
   
4. Last, close the connection

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

from pwn import *
r = remote ("target machine ip", port)
r.sendline(b'A'*60+p64(0x1337bab3)) 
print(r.recvline())
print(r.recvline())
print(r.recvline())
r.close()


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
target machine 167.99.82.136:30381
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

from pwn import *
r = remote ("167.99.82.136", 30381)
r.sendline(b'A'*60+p64(0x1337bab3)) 
print(r.recvline())
print(r.recvline())
print(r.recvline())
r.close()

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Flag captured:

HTB{w3lc0me******!}
 
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
