https://github.com/snguyenpentest/HTB-writeups/issues/1

Here is a description of the retired Jeeves pwnbox:

_"Jeeves is not overly complicated, however, it focuses on some interesting techniques and provides a great learning experience. As the use of alternate data streams is not very common, some users may have a hard time locating the correct escalation path."_

I used @PinkDraconian's and @dannytzoc's YouTube videos for inspiration to better understand binary exploitation and how to execute buffer overflow on this challenge. I highly suggest you give them a follow for more OffSec and HTB CTF content!

https://www.youtube.com/watch?v=W5dVsa3__N4
https://www.youtube.com/watch?v=03Qm8h1L3nw

As with all pwn challenges, we first must download the file from HTB's website.

In order to open this file, we have to use the `chmod +x` command to give us execute priveleges:

`chmod +x jeeves`
![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/84626b55-20f6-4575-ad8c-413884bc6033)

To find out what kind of file we're working with, use the command:
`file jeeves `
![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/b97ede57-a159-4ecf-be78-7c79c94443d8)

Checking out the binary:
• it's 64-bits
• it's not stripped which means that all the original names are still in there. The function names, etc.

Now that we have the file information, we will use Ghidra: https://github.com/NationalSecurityAgency/ghidra

Ghidra is a very nice tool that allows us to generate some pseudo c code from the non-user-friendly assembly code.

`ghidra jeeves`
![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/be62eef1-1d39-484b-82c4-4e20f1f43211)

From opening jeeves into Ghidra, we can see that there's only really a `main` function here from the `/symbol` tree, so let's break down the main function in a simple way.

> 1. First Output: 
>    "Hello, good sir! May I have your name?
> 
> 2. You give it an input:
>    {name}
> 
> 3. It Outputs the received input: 
>    Hello {name}, hope you have a good day!
> 
> 4. However, if this {name} variable is equal to {0x1337bab3} it's going to open flag.txt and print it out to us.
>    "Pleased to make your acquaintance. Here's a small gift: {name}, {flag.txt}"

Okay so let's see if this is also what happens when we run the program. 

When we execute the file using the `./jeeves` command, we see the following (as expected):

![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/8184b27b-bc18-4ba7-b353-2251c81fff08)
Now that we know the output behavior when the input is expected, let's use try to fuzz the program to see if we can generate an unexpected result.

To understand our approach, we must understand the stack requires information from the top, and calls those functions/inputs to be used in later lines.
![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/a7dbb9a1-e529-4dec-bb70-ced8c18bc5fd)
![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/445713e5-50d9-4e3c-a394-f4541883f81c)

This leads us to the approach to the theme of the box: to use **Buffer Overflow** on this stack. 

Additionally, since our buffer input is on top of the stack, if we overflow there, everything below it could also be overflowed... including `local_c` in Line 8, so we need to find a way to overflow lines 5-7, but not 8.

Our first hint is here in Line 5, which `local_48` is defined by an array of 44 characters.
![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/1ab2e40f-7046-47ac-bf9d-cd4082faf6fa)
Knowing this, what if we enter more than 44 characters..?

Using this function below, we'll output 48 “a" characters to use when the jeeves program prompts our input. We can later update the number of “a” characters needed.

	`python -c "print('a' * 48)"   ` 

Now run `./jeeves` again and copy + paste the 48 “a” characters when it prompts us for our input + press enter.
![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/50207639-a851-4d47-92bb-2e0d8a90d079)
On the front-end, the behavior still looks similar to the intended output.

Now, let's try 100 “a" characters
![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/4e01b82d-fc9f-46be-9512-7e83062a6b9f)
We got a segmentation fault error using 100 “a” characters.

The segmentation fault means we were successful in our overflow by overwriting the return address on the stack.
 
However, we overflowed too far! We do not want this as we wanted the overflow to **STOP** on line 8, so it can output us the flag.

![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/bdc04ffd-996b-416d-a334-416a3dcdc416)

![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/8b4d82a0-e9a9-4da7-9c3c-7a040d5f75a1)

_Note: Although we overflowed the stack using 48-characters, we did not receive a segmentation fault._

Unfortunately, the program did not output the flag as Assembly could not process the answer, so let's continue with another route knowing this.

We will need to find out how many padding bytes we need to reach the correct position (overflowing and then stop at Line 8 to input the desired `{0x1337bab3}` input. 

On the left-hand side, we see the hexadecimals of the values. We can quickly convert this to decimals using the internet.

![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/6e59ab30-805a-4b96-a4a9-41ba27e3002f) ![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/470c9d23-e49a-4e55-940f-35c294bc9e66)

Note: `local_c` is located at the Stack [-0xc] hexadecimal

Since we want to find the byte difference between our desired stop position `local_c` and our buffer overflown input `local_48`, We convert the first and last lines of the stack from Hexadecimal to Decimal, and subtract the difference.

From our results:
> local_c [-0xc] -> 12 bytes
> 	local_48 [-0x48] -> 72 bytes
> 
> 72-12 = 60 bytes needed to reach Line 8 local_c, but not overflow it!

or (if we do not have the internet)

> We hover over our stack to find each length from the stack and add them up:

![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/4460b37a-c85d-4943-a1d0-b47cbc1dcefd)


| Stack | Bytes |
| ------------- | ------------- |
| char (buffer - name)  | 44  |
| int   | 4 |
| void (pointer) | 8 |
| int | 4 |
| Total  | 60 padding bytes |

44 + 4 + 8 + 4 = 60 bytes needed to reach Line 8 local_c, but not overflow it


Our payload will have 60 “a” characters, THEN include the desired `local_c` hexadecimal value `0x1337bab3`. 

From @dannytzoc's video, Let's use pwn-tools and create a script to do this.
![image](https://github.com/snguyenpentest/HTB-writeups/assets/147453895/3df5d894-e1c0-48d8-8933-6355d974801b)

from pwn import *
r = remote ("target machine ip", port)
r.sendline(b'A'*60+p64(0x1337bab3)) 
print(r.recvline())
print(r.recvline())
print(r.recvline())
r.close()

The script uses pwn-tools to:

> 1. First, create a Remote SSH tunnel from our localhost machine to target machine using port 30381.
>    
> 2. Send our custom payload of the 60 “a” characters + desired local_c hexadecimal value.
> _Note that we need to include b to notate “bytes” in front of ‘A’ as the script would be trying to concenate dissimilar variables (a string with bytes)._
>          
> 3. Print out the messages once the payload has been received
>    
> 4. Last, close the connection

Note: Replace `target machine ip` and `port` with the information provided by your machine, then Save this script as a python file such as `payload.py`

Lastly, simply run the script using: `python3 payload.py` and capture your flag!
